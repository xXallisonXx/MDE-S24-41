-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\radarSim4\radar.vhd
-- Created: 2024-03-25 15:11:34
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- dist                          ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: radar
-- Source Path: radarSim4/radar
-- Hierarchy Level: 0
-- Model version: 1.37
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.radar_pkg.ALL;

ENTITY radar IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        In1_re                            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
        In1_im                            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
        Input                             :   IN    vector_of_std_logic_vector24(0 TO 127);  -- sfix24_En8 [128]
        Input1_re                         :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
        Input1_im                         :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
        ce_out                            :   OUT   std_logic;
        dist                              :   OUT   std_logic_vector(39 DOWNTO 0)  -- sfix40_En8
        );
END radar;


ARCHITECTURE rtl OF radar IS

  -- Component Declarations
  COMPONENT FreqMeasure
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1_re                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          In1_im                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          Input                           :   IN    vector_of_std_logic_vector24(0 TO 127);  -- sfix24_En8 [128]
          freq                            :   OUT   std_logic_vector(55 DOWNTO 0)  -- sfix56
          );
  END COMPONENT;

  COMPONENT FreqMeasure1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1_re                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          In1_im                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          Input                           :   IN    vector_of_std_logic_vector24(0 TO 127);  -- sfix24_En8 [128]
          freq                            :   OUT   std_logic_vector(55 DOWNTO 0)  -- sfix56
          );
  END COMPONENT;

  COMPONENT Compare_To_Zero
    PORT( u                               :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT If_Action_Subsystem
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          In1                             :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En8
          Action_Port                     :   IN    std_logic;
          Out1                            :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En8
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : FreqMeasure
    USE ENTITY work.FreqMeasure(rtl);

  FOR ALL : FreqMeasure1
    USE ENTITY work.FreqMeasure1(rtl);

  FOR ALL : Compare_To_Zero
    USE ENTITY work.Compare_To_Zero(rtl);

  FOR ALL : If_Action_Subsystem
    USE ENTITY work.If_Action_Subsystem(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL freq                             : std_logic_vector(55 DOWNTO 0);  -- ufix56
  SIGNAL freq_signed                      : signed(55 DOWNTO 0);  -- sfix56
  SIGNAL freq_1                           : std_logic_vector(55 DOWNTO 0);  -- ufix56
  SIGNAL freq_signed_1                    : signed(55 DOWNTO 0);  -- sfix56
  SIGNAL Subtract_sub_temp                : signed(56 DOWNTO 0);  -- sfix57
  SIGNAL Subtract_out1                    : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Compare_To_Zero_out1             : std_logic;
  SIGNAL y2                               : std_logic;
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(103 DOWNTO 0);  -- ufix1 [104]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL Constant2_out1                   : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Add_out1                         : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL If_Action_Subsystem1_out1        : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL If_Action_Subsystem1_out1_signed : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL If_Action_Subsystem_out1         : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL If_Action_Subsystem_out1_signed  : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Merge_out1_prev                  : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Merge_out1                       : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Merge_out1_1                     : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Merge_out1_next_2                : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Merge_out1_dtc                   : signed(24 DOWNTO 0);  -- sfix25_En8
  SIGNAL Constant_out1                    : signed(15 DOWNTO 0);  -- int16
  SIGNAL Divide_out1                      : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Divide_out1_1                    : signed(23 DOWNTO 0);  -- sfix24_En8
  SIGNAL Constant1_out1                   : signed(15 DOWNTO 0);  -- int16
  SIGNAL Constant1_out1_1                 : signed(15 DOWNTO 0);  -- int16
  SIGNAL Product_out1                     : signed(39 DOWNTO 0);  -- sfix40_En8
  SIGNAL Product_out1_1                   : signed(39 DOWNTO 0);  -- sfix40_En8
  SIGNAL Product_out1_dtc                 : signed(40 DOWNTO 0);  -- sfix41_En8
  SIGNAL Constant3_out1                   : signed(15 DOWNTO 0);  -- int16
  SIGNAL dist_tmp                         : signed(39 DOWNTO 0);  -- sfix40_En8

BEGIN
  u_FreqMeasure : FreqMeasure
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1_re => In1_re,  -- sfix24_En8
              In1_im => In1_im,  -- sfix24_En8
              Input => Input,  -- sfix24_En8 [128]
              freq => freq  -- sfix56
              );

  u_FreqMeasure1 : FreqMeasure1
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1_re => Input1_re,  -- sfix24_En8
              In1_im => Input1_im,  -- sfix24_En8
              Input => Input,  -- sfix24_En8 [128]
              freq => freq_1  -- sfix56
              );

  u_Compare_To_Zero : Compare_To_Zero
    PORT MAP( u => std_logic_vector(Subtract_out1),  -- sfix24_En8
              y => Compare_To_Zero_out1
              );

  u_If_Action_Subsystem1 : If_Action_Subsystem
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => std_logic_vector(Add_out1),  -- sfix24_En8
              Action_Port => y2,
              Out1 => If_Action_Subsystem1_out1  -- sfix24_En8
              );

  u_If_Action_Subsystem : If_Action_Subsystem
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              In1 => std_logic_vector(Subtract_out1),  -- sfix24_En8
              Action_Port => Compare_To_Zero_out1,
              Out1 => If_Action_Subsystem_out1  -- sfix24_En8
              );

  freq_signed <= signed(freq);

  freq_signed_1 <= signed(freq_1);

  Subtract_sub_temp <= resize(freq_signed, 57) - resize(freq_signed_1, 57);
  Subtract_out1 <= Subtract_sub_temp(15 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  y2 <=  NOT Compare_To_Zero_out1;

  stateControl_1 <= '1';

  enb <= clk_enable;

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(103 DOWNTO 1) <= delayMatch_reg(102 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(103);

  Constant2_out1 <= to_signed(16#01F400#, 24);

  Add_out1 <= Subtract_out1 + Constant2_out1;

  If_Action_Subsystem1_out1_signed <= signed(If_Action_Subsystem1_out1);

  If_Action_Subsystem_out1_signed <= signed(If_Action_Subsystem_out1);

  
  Merge_out1_1 <= Merge_out1_prev WHEN stateControl_2 = '0' ELSE
      Merge_out1;

  Merge_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Merge_out1_prev <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Merge_out1_prev <= Merge_out1_1;
      END IF;
    END IF;
  END PROCESS Merge_delay_process;


  
  Merge_out1_next_2 <= Merge_out1_prev WHEN y2 = '0' ELSE
      If_Action_Subsystem1_out1_signed;

  
  Merge_out1 <= Merge_out1_next_2 WHEN Compare_To_Zero_out1 = '0' ELSE
      If_Action_Subsystem_out1_signed;

  Merge_out1_dtc <= resize(Merge_out1, 25);

  Constant_out1 <= to_signed(16#0064#, 16);

  Divide_output : PROCESS (Constant_out1, Merge_out1_dtc)
    VARIABLE varargout_1 : signed(24 DOWNTO 0);
    VARIABLE div_temp : signed(25 DOWNTO 0);
    VARIABLE cast : signed(25 DOWNTO 0);
  BEGIN
    div_temp := to_signed(16#0000000#, 26);
    cast := to_signed(16#0000000#, 26);
    IF Constant_out1 = to_signed(16#0000#, 16) THEN 
      IF Merge_out1_dtc < to_signed(16#0000000#, 25) THEN 
        varargout_1 := to_signed(-16#1000000#, 25);
      ELSE 
        varargout_1 := to_signed(16#0FFFFFF#, 25);
      END IF;
    ELSE 
      cast := resize(Merge_out1_dtc, 26);
      div_temp := cast / Constant_out1;
      IF (div_temp(25) = '0') AND (div_temp(24) /= '0') THEN 
        varargout_1 := "0111111111111111111111111";
      ELSIF (div_temp(25) = '1') AND (div_temp(24) /= '1') THEN 
        varargout_1 := "1000000000000000000000000";
      ELSE 
        varargout_1 := div_temp(24 DOWNTO 0);
      END IF;
    END IF;
    IF (varargout_1(24) = '0') AND (varargout_1(23) /= '0') THEN 
      Divide_out1 <= X"7FFFFF";
    ELSIF (varargout_1(24) = '1') AND (varargout_1(23) /= '1') THEN 
      Divide_out1 <= X"800000";
    ELSE 
      Divide_out1 <= varargout_1(23 DOWNTO 0);
    END IF;
  END PROCESS Divide_output;


  HwModeRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Divide_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Divide_out1_1 <= Divide_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  Constant1_out1 <= to_signed(16#0001#, 16);

  HwModeRegister1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Constant1_out1_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Constant1_out1_1 <= Constant1_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product_out1 <= Divide_out1_1 * Constant1_out1_1;

  PipelineRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Product_out1_1 <= to_signed(0, 40);
      ELSIF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Product_out1_dtc <= resize(Product_out1_1, 41);

  Constant3_out1 <= to_signed(16#0002#, 16);

  Divide1_output : PROCESS (Constant3_out1, Product_out1_dtc)
    VARIABLE varargout_11 : signed(40 DOWNTO 0);
    VARIABLE div_temp1 : signed(41 DOWNTO 0);
    VARIABLE cast1 : signed(41 DOWNTO 0);
  BEGIN
    div_temp1 := to_signed(0, 42);
    cast1 := to_signed(0, 42);
    IF Constant3_out1 = to_signed(16#0000#, 16) THEN 
      IF Product_out1_dtc < to_signed(0, 41) THEN 
        varargout_11 := signed'("10000000000000000000000000000000000000000");
      ELSE 
        varargout_11 := signed'("01111111111111111111111111111111111111111");
      END IF;
    ELSE 
      cast1 := resize(Product_out1_dtc, 42);
      div_temp1 := cast1 / Constant3_out1;
      IF (div_temp1(41) = '0') AND (div_temp1(40) /= '0') THEN 
        varargout_11 := "01111111111111111111111111111111111111111";
      ELSIF (div_temp1(41) = '1') AND (div_temp1(40) /= '1') THEN 
        varargout_11 := "10000000000000000000000000000000000000000";
      ELSE 
        varargout_11 := div_temp1(40 DOWNTO 0);
      END IF;
    END IF;
    IF (varargout_11(40) = '0') AND (varargout_11(39) /= '0') THEN 
      dist_tmp <= X"7FFFFFFFFF";
    ELSIF (varargout_11(40) = '1') AND (varargout_11(39) /= '1') THEN 
      dist_tmp <= X"8000000000";
    ELSE 
      dist_tmp <= varargout_11(39 DOWNTO 0);
    END IF;
  END PROCESS Divide1_output;


  dist <= std_logic_vector(dist_tmp);

  ce_out <= clk_enable;

END rtl;

